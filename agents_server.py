#!/usr/bin/env python3
"""
FastAPI server that creates and runs an agent_maker agent.

This module provides a REST API for interacting with an agent_maker agent
powered by Claude 3.7 Sonnet.
"""

import os
import json
import time
from typing import Dict, List, Optional, Any
from pathlib import Path
import uvicorn
from fastapi import FastAPI, HTTPException, Body, BackgroundTasks, Request
from pydantic import BaseModel, Field
import logging
from datetime import datetime
import shutil

from agents import Agent, AgentRunner, get_model_api_keys, AgentResult
from utilities.llm_handler import create_llm_config, generate_llm_response, validate_model_config
from utilities.agent_handler import (
    create_agent_id, store_agent, list_stored_agents,
    get_agent_info, remove_agent
)
from utilities.runtime_handler import setup_runtime_environment, get_runtime_paths
from utilities.api_handler import (
    create_error_response, validate_request_data,
    format_success_response, sanitize_response_data
)

# =============================================================================
# CONSTANTS AND CONFIGURATION
# =============================================================================

# Server port
PORT = 6003
SERVER_PORT = PORT

# Path to agent definitions
AGENT_DEFINITIONS_DIR = Path("./agents_definitions")
AGENT_MAKER_DEFINITION_PATH = AGENT_DEFINITIONS_DIR / "agent_maker.json"

# Runtime directory structure
RUNTIME_BASE_DIR = Path("./all_runtimes")

# Store for custom agents
custom_agents = {}

# =============================================================================
# SETUP AND INITIALIZATION
# =============================================================================

# Setup runtime environment
runtime_paths, logger = setup_runtime_environment(str(RUNTIME_BASE_DIR))

# Initialize with real API
api_keys = get_model_api_keys()
if not api_keys.get("anthropic"):
    logger.error("No Anthropic API key found. Please set ANTHROPIC_API_KEY in your .env file.")
    raise ValueError("Anthropic API key is required")

# Load agent_maker definition
try:
    with open(AGENT_MAKER_DEFINITION_PATH, 'r') as f:
        agent_maker_config = json.load(f)
        logger.info(f"Loaded agent_maker definition from {AGENT_MAKER_DEFINITION_PATH}")
except FileNotFoundError:
    logger.error(f"Agent definition file not found: {AGENT_MAKER_DEFINITION_PATH}")
    raise FileNotFoundError(f"Agent definition file not found: {AGENT_MAKER_DEFINITION_PATH}")
except json.JSONDecodeError:
    logger.error(f"Invalid JSON in agent definition file: {AGENT_MAKER_DEFINITION_PATH}")
    raise ValueError(f"Invalid JSON in agent definition file: {AGENT_MAKER_DEFINITION_PATH}")

# Extract system message from the config
DEFAULT_AGENT_MAKER_SYSTEM_MESSAGE = agent_maker_config.get("system_message", "")

# Initialize the agent_maker
agent_maker = Agent(
    name=agent_maker_config["name"],
    type=agent_maker_config["type"],
    provider=agent_maker_config["provider"],
    model_name=agent_maker_config["model_name"],
    parameters=agent_maker_config["parameters"]
)
agent_maker_runner = AgentRunner(agent_maker)
model_name = f"{agent_maker_config['provider']}/{agent_maker_config['model_name']}"

# Create the FastAPI app
app = FastAPI(
    title="AgentMaker API",
    description="API for creating and running AI agents through the agent_maker",
    version="1.0.0",
)

# =============================================================================
# DATA MODELS
# =============================================================================

class AgentRequest(BaseModel):
    """Request model for the agent endpoint."""
    prompt: str = Field(..., description="The prompt to send to the agent")
    system_message: Optional[str] = Field(
        None, 
        description="Optional system message to override the default one"
    )

class GenerateRequest(BaseModel):
    """Request model for the generate endpoint."""
    prompt: str = Field(..., description="The prompt to send to the LLM")
    model: Optional[str] = Field(
        None, 
        description="Optional model to use for generation"
    )

class AgentResponse(BaseModel):
    """Response model for the agent endpoint."""
    content: str = Field(..., description="The content generated by the agent")
    model: str = Field(..., description="The model used for generation")
    timestamp: float = Field(..., description="The timestamp of the response")

class AgentConfig(BaseModel):
    """Configuration for an agent."""
    name: str = Field(..., description="Name of the agent")
    provider: str = Field(..., description="Provider of the LLM (e.g., 'anthropic', 'openai')")
    model_name: str = Field(..., description="Name of the model to use")
    parameters: Optional[Dict[str, Any]] = Field(
        default_factory=dict,
        description="Optional parameters for the agent"
    )
    
    class Config:
        protected_namespaces = ()  # Fix the model_name protected namespace warning

class AgentCreateResponse(BaseModel):
    """Response model for creating a new agent."""
    agent_id: str = Field(..., description="The ID of the created agent")
    name: str = Field(..., description="The name of the agent")
    status: str = Field("created", description="The status of the agent creation")

# =============================================================================
# SERVER ENDPOINTS
# =============================================================================

@app.on_event("startup")
async def startup_event():
    """Initialize the server and required resources."""
    logger.info("Starting AgentMaker API server")
    logger.info(f"Runtime directory: {runtime_paths['runtime'].absolute()}")
    logger.info(f"Log file: {runtime_paths['logs'] / 'server.log'}")
    logger.info(f"Running with model: {model_name}")

@app.get("/")
def read_root():
    """Root endpoint providing basic server information."""
    return {
        "name": "AgentMaker API",
        "version": "1.0.0",
        "status": "running",
        "model": model_name
    }

@app.post("/generate", response_model=AgentResult)
async def generate(request: GenerateRequest):
    """Generate text from an LLM using the specified model."""
    try:
        # Use the agent_maker to generate a real response
        result = agent_maker_runner.run(request.prompt)
        return result
    except Exception as e:
        logger.error(f"Error during generation: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Generation failed: {str(e)}")

@app.post("/agents", response_model=AgentCreateResponse)
async def create_agent(config: AgentConfig):
    """Create a new agent with the specified configuration."""
    try:
        # Create agent configuration
        agent_config = {
            "name": config.name,
            "type": "chat",
            "provider": config.provider,
            "model_name": config.model_name,
            "parameters": config.parameters
        }
        
        # Create agent instance
        agent = Agent(
            name=config.name,
            type="chat",
            provider=config.provider,
            model_name=config.model_name,
            parameters=config.parameters
        )
        
        # Generate ID and store agent
        agent_id = create_agent_id(config.name)
        
        # Store the agent in our dictionary
        custom_agents[agent_id] = {
            "agent": agent,
            "config": agent_config,
            "creation_time": time.time()
        }
        
        # Create response
        response = AgentCreateResponse(
            agent_id=agent_id,
            name=config.name,
            status="created"
        )
        
        return response
    except Exception as e:
        logger.error(f"Error creating agent: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Agent creation failed: {str(e)}")

@app.post("/agents/{agent_id}/run", response_model=AgentResponse)
async def run_agent(agent_id: str, request: AgentRequest):
    """Run a previously created agent with the given prompt."""
    try:
        # Check if agent exists
        if agent_id not in custom_agents:
            raise HTTPException(status_code=404, detail=f"Agent {agent_id} not found")
            
        agent_info = custom_agents[agent_id]
        agent = agent_info["agent"]
        
        # Create an agent runner if not already cached
        if "runner" not in agent_info:
            agent_info["runner"] = AgentRunner(agent)
        
        runner = agent_info["runner"]
        
        # Set system message if provided
        kwargs = {}
        if request.system_message:
            kwargs["system_message"] = request.system_message
            
        # Run the agent with the prompt
        result = runner.run(request.prompt, **kwargs)
        
        # Format response
        response = AgentResponse(
            content=result.content,
            model=result.model,
            timestamp=result.timestamp
        )
        
        return response
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error running agent: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Agent execution failed: {str(e)}")

@app.get("/agents")
def list_agents():
    """Get a list of all available agents."""
    try:
        agents = []
        for agent_id, info in custom_agents.items():
            agent = info["agent"]
            agents.append({
                "agent_id": agent_id,
                "name": agent.name,
                "provider": agent.provider,
                "model": agent.model_name,
                "creation_time": info.get("creation_time", time.time())
            })
        
        return {"agents": agents}
    except Exception as e:
        logger.error(f"Error listing agents: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to list agents: {str(e)}")

@app.delete("/agents/{agent_id}")
def delete_agent(agent_id: str):
    """Delete a previously created agent."""
    try:
        if agent_id not in custom_agents:
            raise HTTPException(status_code=404, detail=f"Agent {agent_id} not found")
            
        del custom_agents[agent_id]
        
        return {"message": f"Agent {agent_id} deleted successfully"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting agent: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to delete agent: {str(e)}")

# =============================================================================
# SERVER ENTRY POINT
# =============================================================================

if __name__ == "__main__":
    uvicorn.run("agents_server:app", host="0.0.0.0", port=SERVER_PORT, reload=True)
